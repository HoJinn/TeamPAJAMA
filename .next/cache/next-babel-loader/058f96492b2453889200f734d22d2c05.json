{"ast":null,"code":"import { defError, defSuccess, NextAxios } from 'src/axios';\nimport CertificationToken from \"src/entity/CertificationToken\";\nimport { pick, toQuery } from \"src/util\"; // type RequestTokenBody = {\n//   client_id: string,\n//   client_scret: string,\n//   code: string,\n//   state: string\n//   grant_type: string\n// }\n\nexport default ((req, res) => {\n  if (!req.query.social) {\n    res.status(400).json({\n      code: -100,\n      message: '지원하지 않는 소셜 로그인입니다'\n    });\n    return;\n  }\n\n  const {\n    social\n  } = req.query;\n\n  if (social === 'naver') {\n    naverTokenProcess(req, res);\n  } else if (social === 'kakao') {\n    kakaoTokenProcess(req, res);\n  } else if (social === 'google') {\n    googleTokenProcess(req, res);\n  } else {\n    res.status(400).json({\n      code: -100,\n      message: '지원하지 않는 소셜 로그인입니다'\n    });\n  }\n});\n\nconst kakaoTokenProcess = (req, res) => {\n  const clientReqBody = pick(req.query, ['code']);\n\n  if (!clientReqBody) {\n    res.status(400).json({\n      code: -1,\n      message: \"프로퍼티 부족합니다\"\n    });\n    return;\n  }\n\n  const {\n    code\n  } = clientReqBody;\n  const client_id = `${process.env.NEXT_PUBLIC_KAKAO_CLIENT_ID}`;\n  const grant_type = `${process.env.NEXT_PUBLIC_KAKAO_GRANT_TYPE}`;\n  const redirect_uri = `${process.env.NEXT_PUBLIC_KAKAO_RETURN_URL}`; // const client_secret = `${process.env.KAKAO_CLIENT_SECRET}`;\n\n  const reqUrl = `${process.env.KAKAO_TOKEN_URL}`;\n  const params = {\n    code,\n    client_id,\n    redirect_uri,\n    grant_type\n  };\n  const headers = {\n    'content-type': \"application/x-www-form-urlencoded;charset=utf-8\"\n  }; //   -header 'Content-Type: application/x-www-form-urlencoded' \\\n  // --data-urlencode 'client_id=1234567891011-t28d34tfmfk5i5865hm7kij8nvl7vdax.apps.googleusercontent.com' \\\n  // --data-urlencode 'client_secret=KFcsEpfLjg64ta6TtQ1QibOC' \\\n  // --data-urlencode 'grant_type=refresh_token' \\\n  // --data-urlencode 'refresh_token=1/gb5fEFSu_iwbvbsXZdK8ddrJjNTD1RrXbQqdsT6wuJK'\n\n  NextAxios().post(reqUrl, toQuery(params), {\n    headers\n  }).then(axiosRes => {\n    const {\n      data\n    } = defSuccess(axiosRes);\n    const cur = new Date();\n    const tk = new CertificationToken(\"KAKAO\", data.access_token, data.refresh_token, cur, new Date(cur.getTime() + data.expires_in * 1000), data.token_type, data.scope);\n    res.status(200).json(tk);\n  }).catch(err => {\n    const {\n      data\n    } = defError(err);\n    res.status(400).json({\n      code: -100,\n      entity: data\n    });\n  });\n};\n\nconst googleTokenProcess = (req, res) => {\n  const clientReqBody = pick(req.query, ['code', 'scope', 'authuser', 'prompt', 'social']);\n\n  if (!clientReqBody) {\n    res.status(400).json({\n      code: -1,\n      message: \"프로퍼티 부족합니다\"\n    });\n    return;\n  }\n\n  const {\n    code\n  } = clientReqBody;\n  const client_id = `${process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID}`;\n  const client_secret = `${process.env.GOOGLE_CLIENT_SECRET}`;\n  const grant_type = `${process.env.NEXT_PUBLIC_GOOGLE_GRANT_TYPE}`;\n  const redirect_uri = `${process.env.NEXT_PUBLIC_GOOGLE_RETURN_URL}`;\n  const reqUrl = `${process.env.GOOGLE_TOKEN_URL}`;\n  const params = {\n    code,\n    client_id,\n    client_secret,\n    redirect_uri,\n    grant_type\n  }; //   -header 'Content-Type: application/x-www-form-urlencoded' \\\n  // --data-urlencode 'client_id=1234567891011-t28d34tfmfk5i5865hm7kij8nvl7vdax.apps.googleusercontent.com' \\\n  // --data-urlencode 'client_secret=KFcsEpfLjg64ta6TtQ1QibOC' \\\n  // --data-urlencode 'grant_type=refresh_token' \\\n  // --data-urlencode 'refresh_token=1/gb5fEFSu_iwbvbsXZdK8ddrJjNTD1RrXbQqdsT6wuJK'\n\n  NextAxios().post(reqUrl, params).then(axiosRes => {\n    const {\n      data\n    } = defSuccess(axiosRes);\n    const cur = new Date();\n    const tk = new CertificationToken(\"GOOGLE\", data.access_token, data.refresh_token, cur, undefined, undefined // , credential.idToken\n    );\n    res.status(200).json(tk);\n  }).catch(err => {\n    const {\n      data\n    } = defError(err);\n    res.status(400).json({\n      code: -100,\n      // message: data,\n      entity: data\n    });\n  });\n};\n\nconst naverTokenProcess = (req, res) => {\n  const clientReqBody = pick(req.query, ['code', 'state']);\n\n  if (!clientReqBody) {\n    res.status(400).json({\n      code: -1,\n      message: \"프로퍼티 부족합니다\"\n    });\n    return;\n  }\n\n  const {\n    code,\n    state\n  } = clientReqBody;\n  const client_id = `${process.env.NEXT_PUBLIC_NAVER_CLIENT_ID}`;\n  const client_secret = `${process.env.NAVER_CLIENT_SECRET}`;\n  const grant_type = 'authorization_code';\n  const reqUrl = `${process.env.NAVER_TOKEN_URL}`;\n  const params = {\n    code,\n    state,\n    client_id,\n    client_secret,\n    grant_type\n  };\n  NextAxios().get(reqUrl, {\n    params\n  }).then(axiosRes => {\n    const {\n      data\n    } = defSuccess(axiosRes);\n    if (data.error) throw new Error(data.error_description);\n    const cur = new Date();\n    res.status(200).json(new CertificationToken(\"NAVER\", data.access_token, data.refresh_token, cur, new Date(cur.getTime() + data.expires_in * 1000), data.token_type));\n  }).catch(err => {\n    const {\n      data\n    } = defError(err);\n    res.status(400).json({\n      code: -100,\n      entity: data\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"module"}