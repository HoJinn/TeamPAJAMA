{"ast":null,"code":"import moment from 'moment'; // export const NUMBER = /[0-9]/g;\n\nexport const SPECIAL_CHARACTERS = /[~!@\\#$%<>^&*\\|\\\\\\?\\/]/g;\nexport const OTHER_THEN_NUMBER = /\\D/g;\nexport const OTHER_THEN_NUMBER_AND_RELATION = /[^\\d\\.\\-\\+]/g;\nexport const NUMBER_FORM = /^[\\-\\+]?\\d*(\\.\\d+)?$/;\nexport const DIMENSION_FORM = /[\\-\\+]?\\d+(\\.\\d+)?\\s*[^\\n\\s\\b]*/g;\nexport const EMAIL_FORM = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$/i;\nexport const INT_FORM = /^\\d+$/;\nexport const FLOAT_FORM = /^\\d+\\.\\d+$/;\nexport const TAG_FORM = /\\<\\/?[a-z]+[^\\<\\>\\\\]*\\/?\\>/gi;\nexport const SPACE_BAR = /\\s/g; // export const NUMBER_FORM = /^[\\-\\+]?((\\d+\\.?)|(\\.?\\d+)|(\\d+\\.\\d+))$/;\n\nexport const WITH_COMMAS = /\\B(?=(\\d{3})+(?!\\d))/g;\nexport const WITH_HYPHEN = /(^02|^0505|^1[0-9]{3}|^0[0-9]{2})([0-9]+)?([0-9]{4})/;\nexport const WITH_BIRTH = /(^[1-2][0-9]{3}|^0[0-9]{3})([0-9]+)?([0-9]{2})/;\nexport const WITH_GLOBAL_PHONE = /(^[0-9]{2,3}|^0[0-9]{2})|(^[0-9]{2,3}|)([0-9]+)?([0-9]{4})/;\nconst ONE_MINUTE = 60 * 1000,\n      ONE_HOUR = ONE_MINUTE * 60,\n      ONE_DAY = ONE_HOUR * 24,\n      ONE_WEEK = ONE_DAY * 7,\n      ONE_MONTH = ONE_DAY * 30,\n      ONE_YEAR = ONE_DAY * 365;\nconst COMMA = ',';\nexport const EMPTY = '';\nexport const STRING = 'string'; // const NAN = 'NaN';\n\nconst NUMBER = 'number'; // const UNDEFINED = 'undefined';\n\n/** README!!!\r\n *  문자열 관련\r\n *  OUTPUT은 반드시 기본값이 들어갈것\r\n *  (undefind 또는 null이 OUTPUT으로 나오지 않도록)\r\n */\n\n/**금액 3자리수마다 콤마 찍기\r\n * \r\n * @param target : 문자열\r\n * @param def : 기본 값\r\n */\n\nexport const numberWithCommas = (target, def = EMPTY) => {\n  if (!target) return def.toString();\n  return target.toString().replace(OTHER_THEN_NUMBER, EMPTY).replace(WITH_COMMAS, COMMA);\n};\nconst limitNumberOpts = {\n  def: '',\n  max: 100\n};\n/** 입력 숫자 제한\r\n * \r\n * @param target 문자열\r\n * @param {\r\n *  def : 기본 값\r\n *  min : 최소 값\r\n *  max : 최대 값 \r\n * }\r\n */\n\nexport const limitNumber = (target, {\n  def = EMPTY,\n  max = 100,\n  min\n} = limitNumberOpts) => {\n  if (!target || !isNumberForm(target)) return def.toString();\n  const stringNum = target.replace(OTHER_THEN_NUMBER_AND_RELATION, EMPTY);\n  if (stringNum === EMPTY) return def.toString();\n  const num = Number(stringNum);\n  if (min && min > num) return min.toString();else if (max && max < num) return max.toString();else return target;\n};\n/** 빈 문자열 구분. tag는 전부 테스트에서 제외\r\n * \r\n * @param target : 문자열\r\n */\n\nexport const isBlank = target => {\n  return !isUndeclared(target) && (target === EMPTY || typeof target === 'string' && target.replace(TAG_FORM, EMPTY).replace(SPACE_BAR, EMPTY) === EMPTY);\n}; // export const isString = (target: any): target is string => {\n//   return typeof target === STRING;\n// }\n\n/**a와 b의 내용이 같은지 비교\r\n * 순서가 달라도 다른 내용으로 인식\r\n * \r\n * @param a 비교 대상 a\r\n * @param b 비교 대상 b\r\n */\n\nexport const isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);\n/** undefined, null, NaN 구분\r\n * \r\n * @param target 타겟\r\n */\n// export const isUndeclared = (target:any):boolean =>\n//   (\n//     target === null || target === undefined \n//     || (typeof target === NUMBER && isNaN(target)) \n//   );\n\nexport const isUndeclared = target => target === null || target === undefined || typeof target === NUMBER && isNaN(target); // export const isNaN = (target:any):boolean => \n//   target === NaN;\n\n/**숫자 포맷 구분\r\n * \r\n * @param target \r\n */\n\nexport const isNumberForm = target => typeof target === STRING ? NUMBER_FORM.test(target) : Number(target) === target; // Number(num) === num;\n\nexport const isString = target => typeof target === STRING;\n/*\r\nexport const pick = <T, K extends keyof T, F>(\r\n    object: T, \r\n    keys: Array<K>, \r\n    filter:(key: K, val:T[K]) => F|T[K] =  (_key, val) => val\r\n  // ): Pick<T, K> | undefined =>{\r\n  ): Record<K, F|T[K]> | undefined =>{\r\n// export const pick = <T, K extends keyof T, F>(object: T, keys: Array<K>, filter?:(key: K, val:T[K]) => F): Pick<T, K>|Record<K, F> | undefined =>{\r\n  const obj:Record<K, F|T[K]>|any = {}; \r\n  const fail = keys.some(key => {\r\n    let val:T[K]|F = object[key] ;\r\n    if( isUndeclared(val) ) return true;\r\n    val = filter? filter(key, val) as F : val;\r\n    if( isUndeclared(val) ) return true;\r\n    obj[key] = val;\r\n  })\r\n\r\n  if(fail) return undefined;\r\n\r\n  return obj;\r\n}\r\n*/\n// export const isInteger = ( num:any ):boolean => \n//   isNumber(num) && num % 1 === 0;\n\nexport const isFloat = num => isNumberForm(num) && Number(num) % 1 !== 0;\nexport const numberWithHyphen = (val, def = '') => {\n  if (!val) return def;\n  return val.replace(OTHER_THEN_NUMBER, '').replace(WITH_HYPHEN, '$1-$2-$3').replace(\"--\", \"-\");\n};\nexport const numberWithGlobalPhone = (val, def = '') => {\n  if (!val) return def;\n  return val.replace(OTHER_THEN_NUMBER, '').replace(WITH_GLOBAL_PHONE, '+$1)$2-$3-$4').replace(\"--\", \"-\");\n};\nexport const formatBirth = (val, def = '') => {\n  if (!val) return def;\n  return val.replace(OTHER_THEN_NUMBER, '').replace(WITH_BIRTH, '$1-$2-$3').replace(\"--\", \"-\");\n};\nexport const priceCreate = (val, def = 0) => {\n  if (!val) return def;\n  const parseVal = parseInt(val.replace(OTHER_THEN_NUMBER, ''));\n\n  if (val.length > 1 && parseInt(val.slice(0, 1)) < 1) {\n    return parseInt(val.slice(1));\n  }\n\n  return isNaN(parseVal) ? 0 : parseVal;\n};\nexport const hideTextExclude = ({\n  text,\n  start = 'left',\n  padChar = '_',\n  excludeLength\n}) => {\n  if (start === 'left') {\n    const lastNthText = text.substring(0, excludeLength);\n    return lastNthText.padEnd(Math.max(excludeLength, text.length), padChar);\n  } else {\n    const startNthText = text.slice(-excludeLength);\n    return startNthText.padStart(Math.max(excludeLength, text.length), padChar);\n  }\n};\nexport const parseDate = date => {\n  if (typeof date == 'string') {\n    const nums = date.split(/\\D/);\n    return new Date(nums[0] * 1, nums[1] - 1, nums[2] * 1, nums[3] * 1, nums[4] * 1, nums[5] * 1);\n  } else if (date instanceof Date) {\n    return date;\n  } else {\n    return undefined;\n  }\n};\nexport const timeOrDate = (milliseconds, opt = {}) => {\n  if (!isNumberForm(milliseconds)) return '알수없음';\n  const d = moment(milliseconds).toDate(); // const d: Date|undefined = moment(date).;\n  // if(!d || d.getTime() === NaN)\n  //   return '알수없음';\n\n  let cur = new Date();\n  cur = new Date(cur.getFullYear(), cur.getMonth(), cur.getDate()); // let diff =  d.getTime() - cur.getTime();\n\n  const cur_time = cur.getTime();\n  const target_time = d.getTime();\n\n  if (cur_time < target_time && target_time > cur_time + ONE_DAY) {\n    let hour = '' + d.getHours(),\n        minutes = '' + d.getMinutes();\n    hour = hour.length == 1 ? '0' + hour : hour;\n    minutes = minutes.length == 1 ? '0' + minutes : minutes;\n    if (opt.timeSeparator) return `${hour}${opt.timeSeparator}${minutes}`;else return `${hour}시 ${minutes}분`;\n  } else {\n    let year = d.getFullYear(),\n        month = '' + (d.getMonth() + 1),\n        day = '' + d.getDate();\n    month = month.length == 1 ? '0' + month : month;\n    day = day.length == 1 ? '0' + day : day;\n    if (opt.dateSeparator) return `${year !== cur.getFullYear() ? `${year}${opt.dateSeparator}` : ''}${month}${opt.dateSeparator}${day}`;else return `${year !== cur.getFullYear() ? `${year}년 ` : ''}${month}월 ${day}일`;\n  } // return '';\n\n};\nexport const aboutDate = (milliseconds, opt) => {\n  if (!isNumberForm(milliseconds)) return '알수없음';\n  let cur;\n  if (opt) cur = opt.cur;\n  if (!cur) cur = new Date();\n  const d = moment(milliseconds).toDate();\n  const d_long = d.getTime(),\n        cur_long = cur.getTime();\n  let diff = cur_long - d_long;\n\n  if (diff > 0) {\n    // 양수. 과거\n    if (opt === null || opt === void 0 ? void 0 : opt.under) return opt.under;\n\n    if (diff > ONE_YEAR) {\n      return `${Math.floor(diff / ONE_YEAR)}년 전`;\n    } else if (diff > ONE_MONTH) {\n      return `${Math.floor(diff / ONE_MONTH)}달 전`;\n    } else if (diff > ONE_WEEK) {\n      return `${Math.floor(diff / ONE_WEEK)}주일 전`;\n    } else if (diff > ONE_DAY) {\n      return `${Math.floor(diff / ONE_DAY)}일 전`;\n    } else if (diff > ONE_HOUR) {\n      return `${Math.floor(diff / ONE_HOUR)}시간 전`;\n    } else if (diff > ONE_MINUTE) {\n      return `${Math.floor(diff / ONE_MINUTE)}분 전`;\n    } else {\n      return '방금전';\n    }\n  } else {\n    //음수. 미래\n    if (opt === null || opt === void 0 ? void 0 : opt.excess) return opt.excess;\n    diff = Math.abs(diff);\n\n    if (diff > ONE_YEAR) {\n      return `${Math.floor(diff / ONE_YEAR)}년 후`;\n    } else if (diff > ONE_MONTH) {\n      return `${Math.floor(diff / ONE_MONTH)}달 후`;\n    } else if (diff > ONE_WEEK) {\n      return `${Math.floor(diff / ONE_WEEK)}주일 후`;\n    } else if (diff > ONE_DAY) {\n      return `${Math.floor(diff / ONE_DAY)}일 후`;\n    } else if (diff > ONE_HOUR) {\n      return `${Math.floor(diff / ONE_HOUR)}시간 후`;\n    } else if (diff > ONE_MINUTE) {\n      return `${Math.floor(diff / ONE_MINUTE)}분 후`;\n    } else {\n      return '잠시후';\n    }\n  }\n};\nexport const dataSizeParse = size => {\n  const s = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'];\n  const e = Math.floor(Math.log(size) / Math.log(1024));\n  return (size / Math.pow(1024, e)).toFixed(2) + \" \" + s[e];\n};","map":null,"metadata":{},"sourceType":"module"}