{"ast":null,"code":"import moment from 'moment'; // export const NUMBER = /[0-9]/g;\n\nexport var SPECIAL_CHARACTERS = /[~!@\\#$%<>^&*\\|\\\\\\?\\/]/g;\nexport var OTHER_THEN_NUMBER = /\\D/g;\nexport var OTHER_THEN_NUMBER_AND_RELATION = /[^\\d\\.\\-\\+]/g;\nexport var NUMBER_FORM = /^[\\-\\+]?\\d*(\\.\\d+)?$/;\nexport var DIMENSION_FORM = /[\\-\\+]?\\d+(\\.\\d+)?\\s*[^\\n\\s\\b]*/g;\nexport var EMAIL_FORM = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$/i;\nexport var INT_FORM = /^\\d+$/;\nexport var FLOAT_FORM = /^\\d+\\.\\d+$/;\nexport var TAG_FORM = /\\<\\/?[a-z]+[^\\<\\>\\\\]*\\/?\\>/gi;\nexport var SPACE_BAR = /\\s/g; // export const NUMBER_FORM = /^[\\-\\+]?((\\d+\\.?)|(\\.?\\d+)|(\\d+\\.\\d+))$/;\n\nexport var WITH_COMMAS = /\\B(?=(\\d{3})+(?!\\d))/g;\nexport var WITH_HYPHEN = /(^02|^0505|^1[0-9]{3}|^0[0-9]{2})([0-9]+)?([0-9]{4})/;\nexport var WITH_BIRTH = /(^[1-2][0-9]{3}|^0[0-9]{3})([0-9]+)?([0-9]{2})/;\nexport var WITH_GLOBAL_PHONE = /(^[0-9]{2,3}|^0[0-9]{2})|(^[0-9]{2,3}|)([0-9]+)?([0-9]{4})/;\nvar ONE_MINUTE = 60 * 1000,\n    ONE_HOUR = ONE_MINUTE * 60,\n    ONE_DAY = ONE_HOUR * 24,\n    ONE_WEEK = ONE_DAY * 7,\n    ONE_MONTH = ONE_DAY * 30,\n    ONE_YEAR = ONE_DAY * 365;\nvar COMMA = ',';\nexport var EMPTY = '';\nexport var STRING = 'string'; // const NAN = 'NaN';\n\nvar NUMBER = 'number'; // const UNDEFINED = 'undefined';\n\n/** README!!!\r\n *  문자열 관련\r\n *  OUTPUT은 반드시 기본값이 들어갈것\r\n *  (undefind 또는 null이 OUTPUT으로 나오지 않도록)\r\n */\n\n/**금액 3자리수마다 콤마 찍기\r\n * \r\n * @param target : 문자열\r\n * @param def : 기본 값\r\n */\n\nexport var numberWithCommas = function numberWithCommas(target) {\n  var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY;\n  if (!target) return def.toString();\n  return target.toString().replace(OTHER_THEN_NUMBER, EMPTY).replace(WITH_COMMAS, COMMA);\n};\nvar limitNumberOpts = {\n  def: '',\n  max: 100\n};\n/** 입력 숫자 제한\r\n * \r\n * @param target 문자열\r\n * @param {\r\n *  def : 기본 값\r\n *  min : 최소 값\r\n *  max : 최대 값 \r\n * }\r\n */\n\nexport var limitNumber = function limitNumber(target) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : limitNumberOpts,\n      _ref$def = _ref.def,\n      def = _ref$def === void 0 ? EMPTY : _ref$def,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 100 : _ref$max,\n      min = _ref.min;\n\n  if (!target || !isNumberForm(target)) return def.toString();\n  var stringNum = target.replace(OTHER_THEN_NUMBER_AND_RELATION, EMPTY);\n  if (stringNum === EMPTY) return def.toString();\n  var num = Number(stringNum);\n  if (min && min > num) return min.toString();else if (max && max < num) return max.toString();else return target;\n};\n/** 빈 문자열 구분. tag는 전부 테스트에서 제외\r\n * \r\n * @param target : 문자열\r\n */\n\nexport var isBlank = function isBlank(target) {\n  return !isUndeclared(target) && (target === EMPTY || typeof target === 'string' && target.replace(TAG_FORM, EMPTY).replace(SPACE_BAR, EMPTY) === EMPTY);\n}; // export const isString = (target: any): target is string => {\n//   return typeof target === STRING;\n// }\n\n/**a와 b의 내용이 같은지 비교\r\n * 순서가 달라도 다른 내용으로 인식\r\n * \r\n * @param a 비교 대상 a\r\n * @param b 비교 대상 b\r\n */\n\nexport var isEqual = function isEqual(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n/** undefined, null, NaN 구분\r\n * \r\n * @param target 타겟\r\n */\n// export const isUndeclared = (target:any):boolean =>\n//   (\n//     target === null || target === undefined \n//     || (typeof target === NUMBER && isNaN(target)) \n//   );\n\nexport var isUndeclared = function isUndeclared(target) {\n  return target === null || target === undefined || typeof target === NUMBER && isNaN(target);\n}; // export const isNaN = (target:any):boolean => \n//   target === NaN;\n\n/**숫자 포맷 구분\r\n * \r\n * @param target \r\n */\n\nexport var isNumberForm = function isNumberForm(target) {\n  return typeof target === STRING ? NUMBER_FORM.test(target) : Number(target) === target;\n}; // Number(num) === num;\n\nexport var isString = function isString(target) {\n  return typeof target === STRING;\n};\n/*\r\nexport const pick = <T, K extends keyof T, F>(\r\n    object: T, \r\n    keys: Array<K>, \r\n    filter:(key: K, val:T[K]) => F|T[K] =  (_key, val) => val\r\n  // ): Pick<T, K> | undefined =>{\r\n  ): Record<K, F|T[K]> | undefined =>{\r\n// export const pick = <T, K extends keyof T, F>(object: T, keys: Array<K>, filter?:(key: K, val:T[K]) => F): Pick<T, K>|Record<K, F> | undefined =>{\r\n  const obj:Record<K, F|T[K]>|any = {}; \r\n  const fail = keys.some(key => {\r\n    let val:T[K]|F = object[key] ;\r\n    if( isUndeclared(val) ) return true;\r\n    val = filter? filter(key, val) as F : val;\r\n    if( isUndeclared(val) ) return true;\r\n    obj[key] = val;\r\n  })\r\n\r\n  if(fail) return undefined;\r\n\r\n  return obj;\r\n}\r\n*/\n// export const isInteger = ( num:any ):boolean => \n//   isNumber(num) && num % 1 === 0;\n\nexport var isFloat = function isFloat(num) {\n  return isNumberForm(num) && Number(num) % 1 !== 0;\n};\nexport var numberWithHyphen = function numberWithHyphen(val) {\n  var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (!val) return def;\n  return val.replace(OTHER_THEN_NUMBER, '').replace(WITH_HYPHEN, '$1-$2-$3').replace(\"--\", \"-\");\n};\nexport var numberWithGlobalPhone = function numberWithGlobalPhone(val) {\n  var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (!val) return def;\n  return val.replace(OTHER_THEN_NUMBER, '').replace(WITH_GLOBAL_PHONE, '+$1)$2-$3-$4').replace(\"--\", \"-\");\n};\nexport var formatBirth = function formatBirth(val) {\n  var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (!val) return def;\n  return val.replace(OTHER_THEN_NUMBER, '').replace(WITH_BIRTH, '$1-$2-$3').replace(\"--\", \"-\");\n};\nexport var priceCreate = function priceCreate(val) {\n  var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!val) return def;\n  var parseVal = parseInt(val.replace(OTHER_THEN_NUMBER, ''));\n\n  if (val.length > 1 && parseInt(val.slice(0, 1)) < 1) {\n    return parseInt(val.slice(1));\n  }\n\n  return isNaN(parseVal) ? 0 : parseVal;\n};\nexport var hideTextExclude = function hideTextExclude(_ref2) {\n  var text = _ref2.text,\n      _ref2$start = _ref2.start,\n      start = _ref2$start === void 0 ? 'left' : _ref2$start,\n      _ref2$padChar = _ref2.padChar,\n      padChar = _ref2$padChar === void 0 ? '_' : _ref2$padChar,\n      excludeLength = _ref2.excludeLength;\n\n  if (start === 'left') {\n    var lastNthText = text.substring(0, excludeLength);\n    return lastNthText.padEnd(Math.max(excludeLength, text.length), padChar);\n  } else {\n    var startNthText = text.slice(-excludeLength);\n    return startNthText.padStart(Math.max(excludeLength, text.length), padChar);\n  }\n};\nexport var parseDate = function parseDate(date) {\n  if (typeof date == 'string') {\n    var nums = date.split(/\\D/);\n    return new Date(nums[0] * 1, nums[1] - 1, nums[2] * 1, nums[3] * 1, nums[4] * 1, nums[5] * 1);\n  } else if (date instanceof Date) {\n    return date;\n  } else {\n    return undefined;\n  }\n};\nexport var timeOrDate = function timeOrDate(milliseconds) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!isNumberForm(milliseconds)) return '알수없음';\n  var d = moment(milliseconds).toDate(); // const d: Date|undefined = moment(date).;\n  // if(!d || d.getTime() === NaN)\n  //   return '알수없음';\n\n  var cur = new Date();\n  cur = new Date(cur.getFullYear(), cur.getMonth(), cur.getDate()); // let diff =  d.getTime() - cur.getTime();\n\n  var cur_time = cur.getTime();\n  var target_time = d.getTime();\n\n  if (cur_time < target_time && target_time > cur_time + ONE_DAY) {\n    var hour = '' + d.getHours(),\n        minutes = '' + d.getMinutes();\n    hour = hour.length == 1 ? '0' + hour : hour;\n    minutes = minutes.length == 1 ? '0' + minutes : minutes;\n    if (opt.timeSeparator) return \"\".concat(hour).concat(opt.timeSeparator).concat(minutes);else return \"\".concat(hour, \"\\uC2DC \").concat(minutes, \"\\uBD84\");\n  } else {\n    var year = d.getFullYear(),\n        month = '' + (d.getMonth() + 1),\n        day = '' + d.getDate();\n    month = month.length == 1 ? '0' + month : month;\n    day = day.length == 1 ? '0' + day : day;\n    if (opt.dateSeparator) return \"\".concat(year !== cur.getFullYear() ? \"\".concat(year).concat(opt.dateSeparator) : '').concat(month).concat(opt.dateSeparator).concat(day);else return \"\".concat(year !== cur.getFullYear() ? \"\".concat(year, \"\\uB144 \") : '').concat(month, \"\\uC6D4 \").concat(day, \"\\uC77C\");\n  } // return '';\n\n};\nexport var aboutDate = function aboutDate(milliseconds, opt) {\n  if (!isNumberForm(milliseconds)) return '알수없음';\n  var cur;\n  if (opt) cur = opt.cur;\n  if (!cur) cur = new Date();\n  var d = moment(milliseconds).toDate();\n  var d_long = d.getTime(),\n      cur_long = cur.getTime();\n  var diff = cur_long - d_long;\n\n  if (diff > 0) {\n    // 양수. 과거\n    if (opt === null || opt === void 0 ? void 0 : opt.under) return opt.under;\n\n    if (diff > ONE_YEAR) {\n      return \"\".concat(Math.floor(diff / ONE_YEAR), \"\\uB144 \\uC804\");\n    } else if (diff > ONE_MONTH) {\n      return \"\".concat(Math.floor(diff / ONE_MONTH), \"\\uB2EC \\uC804\");\n    } else if (diff > ONE_WEEK) {\n      return \"\".concat(Math.floor(diff / ONE_WEEK), \"\\uC8FC\\uC77C \\uC804\");\n    } else if (diff > ONE_DAY) {\n      return \"\".concat(Math.floor(diff / ONE_DAY), \"\\uC77C \\uC804\");\n    } else if (diff > ONE_HOUR) {\n      return \"\".concat(Math.floor(diff / ONE_HOUR), \"\\uC2DC\\uAC04 \\uC804\");\n    } else if (diff > ONE_MINUTE) {\n      return \"\".concat(Math.floor(diff / ONE_MINUTE), \"\\uBD84 \\uC804\");\n    } else {\n      return '방금전';\n    }\n  } else {\n    //음수. 미래\n    if (opt === null || opt === void 0 ? void 0 : opt.excess) return opt.excess;\n    diff = Math.abs(diff);\n\n    if (diff > ONE_YEAR) {\n      return \"\".concat(Math.floor(diff / ONE_YEAR), \"\\uB144 \\uD6C4\");\n    } else if (diff > ONE_MONTH) {\n      return \"\".concat(Math.floor(diff / ONE_MONTH), \"\\uB2EC \\uD6C4\");\n    } else if (diff > ONE_WEEK) {\n      return \"\".concat(Math.floor(diff / ONE_WEEK), \"\\uC8FC\\uC77C \\uD6C4\");\n    } else if (diff > ONE_DAY) {\n      return \"\".concat(Math.floor(diff / ONE_DAY), \"\\uC77C \\uD6C4\");\n    } else if (diff > ONE_HOUR) {\n      return \"\".concat(Math.floor(diff / ONE_HOUR), \"\\uC2DC\\uAC04 \\uD6C4\");\n    } else if (diff > ONE_MINUTE) {\n      return \"\".concat(Math.floor(diff / ONE_MINUTE), \"\\uBD84 \\uD6C4\");\n    } else {\n      return '잠시후';\n    }\n  }\n};\nexport var dataSizeParse = function dataSizeParse(size) {\n  var s = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'];\n  var e = Math.floor(Math.log(size) / Math.log(1024));\n  return (size / Math.pow(1024, e)).toFixed(2) + \" \" + s[e];\n};","map":null,"metadata":{},"sourceType":"module"}